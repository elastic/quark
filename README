QUARK(7)               Miscellaneous Information Manual               QUARK(7)

NNAAMMEE
     qquuaarrkk - unified system process telemetry library

DDEESSCCRRIIPPTTIIOONN
     qquuaarrkk is a library that provides a way to retrieve and listen to process
     events in linux systems.  Its main purpose is to abstract different
     backends and to provide a common API for listening to system-wide events
     like ffoorrkk(_2), eexxeecc(_3), eexxiitt(_3) and others.

     qquuaarrkk not only provides an API for listening to events, but also handles
     ordering, buffering and aggregation of said events.  In its most basic
     form, a short lived process consisting of ffoorrkk(_2) + eexxeecc(_3) + eexxiitt(_3)
     will be aggregated into one _q_u_a_r_k___e_v_e_n_t.  An internal event cache is also
     kept that can be looked up via qquuaarrkk__eevveenntt__llooookkuupp(_3).

FFEEAATTUURREESS
     _O_R_D_E_R_I_N_G
     qquuaarrkk tries to guarantee event ordering as much as possible.  Ordering
     must be done in userland for some backends, notably anything that uses
     perf-rings.  qquuaarrkk uses two _R_a_n_k _B_a_l_a_n_c_e_d _T_r_e_e_s for ordering and
     aggregation.

     The first tree is basically a priority queue, ordered by the time of the
     event.  The second tree is ordered by time of the event + pid and it's
     used for event aggregation.

     _A_G_G_R_E_G_A_T_I_O_N
     qquuaarrkk buffers and aggregates related events that happened close enough.
     The common case is generating a single event for the triple: ffoorrkk(_2),
     eexxeecc(_3), eexxiitt(_3).  There are rules on what can be aggregated, and only
     events of the same pid are aggregated.  For example: qquuaarrkk won't
     aggregate two eexxeecc(_3) events, otherwise we would lose the effects of the
     first one.  These rules will be exposed and configurable in the future.

     _B_U_F_F_E_R_I_N_G
     For aggregation and ordering to work, qquuaarrkk needs to be able to buffer
     events, this means holding them before presenting them to the user.
     qquuaarrkk employs an ageing timeout that is a stepped function of the number
     of currently buffered events, the more events you have, the shorter the
     timeout will be, so memory can be bound.  A _q_u_a_r_k___e_v_e_n_t is only given to
     the user when it has a certain age.  From quark.c:

           /*
            * Target age is the duration in ns of how long should we hold the event in the
            * tree before processing it. It's a function of the number of items in the tree
            * and its maximum capacity:
            * from [0; 10%]    -> 1000ms
            * from [90%; 100%] -> 0ms
            * from (10%; 90%)  -> linear from 1000ms -> 100ms
            */

     _E_N_R_I_C_H_M_E_N_T
     The library tries to give as much context for an event as possible.
     Depending on the backend, the events we read from the kernel can be
     limited in context.  qquuaarrkk maintains an internal process table with what
     has been learned about the process so far, this context is then included
     in each event given to the user.  The process table can also be queried,
     see below.

     _P_R_O_C_E_S_S _T_A_B_L_E
     An internal cache of process events is kept that can be looked up via
     qquuaarrkk__eevveenntt__llooookkuupp(_3).  This cache keeps soon-to-be-purged elements for a
     little while so that you can still lookup a process that just exited.
     The table is initialized by scraping _/_p_r_o_c.

     _T_R_A_N_S_P_A_R_E_N_C_Y
     qquuaarrkk tries to be as transparent as possible about what it knows, there
     are counters for lost events, and each piece of information of a
     _q_u_a_r_k___e_v_e_n_t is guarded by a flag, meaning the user might get incomplete
     events in the case of lost events, it's the user responsability to decide
     what to do with it.

     Depending on load, the user might see an event as the aggregation of
     multiple events, or as independent events.  The content remains the same.

     _L_A_N_G_U_A_G_E _B_I_N_D_I_N_G_S
     qquuaarrkk is written in C, but Go bindings are also provided.  Ideally we
     will be able to provide bindings for other languages in the future.

     _M_U_L_T_I_P_L_E _B_A_C_K_E_N_D_S (future)
     Currently only a kprobe-based backend is provided, but we would like to
     add eBPF and AUDIT support as well.  The user API should remain the same,
     so if we do this right, the user shouldn't even know which backend is
     being used.  Proper runtime discovery is needed to know what we can use.

BBUUIILLDDIINNGG
     _m_a_k_e generates a _l_i_b_q_u_a_r_k_._a that can be linked with the user binary, be
     sure to clone the repository with _g_i_t _c_l_o_n_e _-_-_r_e_c_u_r_s_i_v_e.

     qquuaarrkk builds its own _l_i_b_b_p_f since it needs BTF support from it.  At the
     time of this writing, _l_i_b_q_u_a_r_k_._a also needs symbols from _l_i_b_z and _l_i_b_e_l_f.
     An option will be given in the future to include both in the archive.

     Other useful build targets include:

     _m_a_n_l_i_n_t  Calls the linter for all manpages.

     _s_v_g      Builds an SVG out of the DOT files produced by quark-mon(8).

     _R_E_A_D_M_E_._m_d
              Generate _R_E_A_D_M_E_._m_d out of _q_u_a_r_k_._7.

LLIINNKKIINNGG
     cc -o myprogram myprogram.c -lelf -lz libquark.a libbpf/src/libbpf.a

IINNCCLLUUDDEEDD BBIINNAARRIIEESS
     quark-mon(8) is a program that dumps _q_u_a_r_k___e_v_e_n_t_s to stdout and can be
     used for demo and debugging.  It has a neat feature: can be run without
     priviledges, while useless in this small program, it aims to demonstrate
     how a user could implement the same.

     quark-btf(8) is a program for dumping BTF information used by qquuaarrkk.

CCOONNVVEENNTTIIOONNSS
     ++oo   Library calls fail with -1 unless otherwise stated, and _e_r_r_n_o is set.

     ++oo   No pointers to internal state are returned, data is allocated by the
         caller and the library copies out.

     ++oo   No threads are created, the library is driven solely through
         qquuaarrkk__qquueeuuee__ggeett__eevveennttss(_3).

     ++oo   Access to a _q_u_a_r_k___q_u_e_u_e must be synchronized by the user in the case
         of multithreading.

BBAASSIICC UUSSAAGGEE
     The ball starts with qquuaarrkk__iinniitt(_3) followed by qquuaarrkk__qquueeuuee__ooppeenn(_3).

     qquuaarrkk__iinniitt(_3) initializes internal global state for the library that
     should be paired with qquuaarrkk__cclloossee(_3) on exit.  At the time of this
     writing, this is basically initializing some per-host state, trying to
     read _B_T_F from the host and initilizing kprobes .

     qquuaarrkk__qquueeuuee__ooppeenn(_3) initializes a _q_u_a_r_k___q_u_e_u_e which holds the majority of
     runtime state used by library, this includes perf-rings, file
     descriptors, buffering data-structures and the like.  It must be paired
     with a qquuaarrkk__qquueeuuee__cclloossee(_3) on exit.

     qquuaarrkk__qquueeuuee__ggeett__eevveennttss(_3) Is the main driver of the library, it does the
     buffering, per-ring scanning, aggregation and event cache garbage
     collecting.  In case there are no events it returns zero and the user is
     expected to call qquuaarrkk__qquueeuuee__bblloocckk(_3) or equivalent.

EEXXAAMMPPLLEESS
           #include <err.h>
           #include <quark.h>
           #include <stdio.h>

           int
           main(void)
           {
                   struct quark_queue      qq;
                   struct quark_event      qevs[32], *qev;
                   int                     n, i;

                   if (quark_init() == -1)
                           err(1, "quark_init");
                   if (quark_queue_open(&qq, 0) == -1)
                           err(1, "quark_queue_open");

                   for (; ;) {
                           n = quark_queue_get_events(&qq, qevs, 32);
                           if (n == -1) {
                                   warn("quark_queue_get_events");
                                   break;
                           }
                           /* Scan each event */
                           for (i = 0, qev = qevs; i < n; i++, qev++)
                                   quark_event_dump(qev, stdout);
                           if (n == 0)
                                   quark_queue_block(&qq);
                   }

                   quark_queue_close(&qq);
                   quark_close();

                   return (1);
           }

FFUURRTTHHEERR RREEAADDIINNGG
     quark_queue_get_events(3) is the meat of the library and contains further
     useful documentation.

     quark-mon(8) is the easiest way to get started with qquuaarrkk.

SSEEEE AALLSSOO
     quark_close(3), quark_event_dump(3), quark_event_lookup(3),
     quark_init(3), quark_queue_block(3), quark_queue_close(3),
     quark_queue_get_events(3), quark_queue_get_fds(3), quark_queue_open(3),
     quark-btf(8), quark-mon(8)

HHIISSTTOORRYY
     qquuaarrkk started in April 2024.

Linux 6.7.11-100.fc38.x86_64     April 8, 2024    Linux 6.7.11-100.fc38.x86_64

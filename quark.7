.Dd $Mdocdate$
.Dt QUARK 7
.Os
.Sh NAME
.Nm quark
.Nd unified system process telemetry library
.Sh DESCRIPTION
.Nm
is a library that provides a way to retrieve and listen to process events in
linux systems.
Its main purpose is to abstract different backends and to provide a common
API for listening to system-wide events like
.Xr fork 2 ,
.Xr exec 3 ,
.Xr exit 3
and others.
.Pp
.Nm quark
not only provides an API for listening to events, but also handles ordering,
buffering and aggregation of said events.
In its most basic form, a short lived process consisting of
.Xr fork 2
+
.Xr exec 3
+
.Xr exit 3
will be aggregated into one
.Vt quark_event .
An internal event cache is also kept that can be looked up via
.Xr quark_event_lookup 3 .
.Sh FEATURES
.Bl -ohang
.It Em ORDERING
.Nm
tries to guarantee event ordering as much as possible.
Ordering must be done in userland for some backends, notably anything that
uses perf-rings.
.Nm
uses two
.Em Rank Balanced Trees
for ordering and aggregation.
.Pp
The first tree is basically a priority queue, ordered by the time of the
event.
The second tree is ordered by time of the event + pid and it's used for event
aggregation.
.It Em AGGREGATION
.Nm
buffers and aggregates related events that happened close enough.
The common case is generating a single event for the triple:
.Xr fork 2 ,
.Xr exec 3 ,
.Xr exit 3 .
There are rules on what can be aggregated, and only events of the same pid are
aggregated.
For example:
.Nm
won't aggregate two
.Xr exec 3
events, otherwise we would lose the effects of the first one.
These rules will be exposed and configurable in the future.
.It Em BUFFERING
For aggregation and ordering to work,
.Nm
needs to be able to buffer events, this means holding them before presenting
them to the user.
.Nm
employs an ageing timeout that is a stepped function of the number of currently
buffered events, the more events you have, the shorter the timeout will be, so
memory can be bound.
A
.Vt quark_event
is only given to the user when it has a certain age.
From quark.c:
.Bd -literal -offset indent
/*
 * Target age is the duration in ns of how long should we hold the event in the
 * tree before processing it. It's a function of the number of items in the tree
 * and its maximum capacity:
 * from [0; 10%]    -> 1000ms
 * from [90%; 100%] -> 0ms
 * from (10%; 90%)  -> linear from 1000ms -> 100ms
 */
.Ed
.It Em ENRICHMENT
The library tries to give as much context for an event as possible.
Depending on the backend, the events we read from the kernel can be limited in
context.
.Nm
maintains an internal process table with what has been learned about the process
so far, this context is then included in each event given to the user.
The process table can also be queried, see below.
.It Em PROCESS TABLE
An internal cache of process events is kept that can be looked up via
.Xr quark_event_lookup 3 .
This cache keeps soon-to-be-purged elements for a little while so that you can
still lookup a process that just exited.
The table is initialized by scraping
.Pa /proc .
.It Em TRANSPARENCY
.Nm
tries to be as transparent as possible about what it knows, there are counters
for lost events, and each piece of information of a
.Vt quark_event
is guarded by a flag, meaning the user might get incomplete events in the case
of lost events, it's the user responsability to decide what to do with it.
.Pp
Depending on load, the user might see an event as the aggregation of multiple
events, or as independent events.
The content remains the same.
.It Em LANGUAGE BINDINGS
.Nm
is written in C, but Go bindings are also provided.
Ideally we will be able to provide bindings for other languages in the future.
.It Em MULTIPLE BACKENDS
Currently, EBPF and a kprobe-based backend are provided, but we would like
to add AUDIT support as well.
The backend in use is transparent to the user and unless specified,
.Nm
will try to use the EBPF, falling back to KPROBE if it failed.
.El
.Sh BUILDING
Make sure to clone the repository recursively:
.Em "git clone --recursive" .
.Pp
.Em make
generates a
.Pa libquark_big.a
and a
.Pa libquark.a .
.Pp
.Pa libquark_big.a
includes all needed dependencies in one big archive.
This includes a
.Pa libbpf.a ,
.Pa libelf_pic.a
(from the elftoolchain project, BSD license),
and a
.Pa libz.a
(see zlib/LICENSE).
See
.Sx LINKING
to learn how to link either.
.Pp
While
.Nm
doesn't build
.Em elastic/ebpf ,
it does use the EBPF programs from that repository, only the files needed are
included in
.Nm ,
as
.Em elastic/ebpf
is quite big.
.Pp
Other useful build targets include:
.Bl -tag -width "manlint"
.It Em clean
Clean object files from
.Nm .
.It Em cleanall
Clean all object files, including the ones from
.Em libbpf ,
.Em libz
and
.Em libelf .
.It Em doc
Shorthand for manlint+manhtml+README.md, see below.
.It Em manlint
Calls the linter for all manpages.
.It Em manhtml
Generates HTML files for the manpges in manhtml/.
.It Em svg
Builds an SVG out of the DOT files produced by
.Xr quark-mon 8 .
.It Em README.md
Generates
.Pa README.md
out of
.Pa quark.7 .
.It Em eebpf-sync
Copies the files from EEBPF_PATH used by
.Nm .
Usage:
.Bd -literal
make eebpf-sync EEBPF_PATH=/my/path/to/elastic/ebpf
.Ed
.El
.Sh LINKING
.Bd -literal
cc -o myprogram myprogram.c libquark_big.a
OR
cc -o myprogram myprogram.c libquark.a libbpf/src/libbpf.a elftoolchain/libelf/libelf_pic.a zlib/libz.a
.Ed
.Sh INCLUDED BINARIES
.Xr quark-mon 8
is a program that dumps
.Vt quark_events
to stdout and can be used for demo and debugging.
It has a neat feature: can be run without priviledges, while useless in this
small program, it aims to demonstrate how a user could implement the same.
.Pp
.Xr quark-btf 8
is a program for dumping BTF information used by
.Nm .
.Sh CONVENTIONS
.Bl -bullet
.It
Library calls fail with -1 unless otherwise stated, and
.Va errno
is set.
.It
No pointers to internal state are returned, data is allocated by the caller and
the library copies out.
.It
No threads are created, the library is driven solely through
.Xr quark_queue_get_events 3 .
.It
Access to a
.Vt quark_queue
must be synchronized by the user in the case of multithreading.
.El
.Sh BASIC USAGE
The ball starts with
.Xr quark_queue_open 3 .
.Pp
.Xr quark_queue_open 3
initializes a
.Vt quark_queue
which holds the majority of runtime state used by library, this includes
perf-rings, file descriptors, EBPF programs buffering data-structures and the
like.
It must be paired with a
.Xr quark_queue_close 3
on exit.
.Pp
.Xr quark_queue_get_events 3
is the main driver of the library, it does the buffering, per-ring scanning,
aggregation and event cache garbage collecting.
In case there are no events it
returns zero and the user is expected to call
.Xr quark_queue_block 3
or equivalent.
.Sh EXAMPLES
.Bd -literal -offset indent
#include <err.h>
#include <quark.h>
#include <stdio.h>

int
main(void)
{
	struct quark_queue	qq;
	struct quark_event	qevs[32], *qev;
	int			n, i;

	if (quark_queue_open(&qq, NULL) == -1)
		err(1, "quark_queue_open");

	for (; ;) {
		n = quark_queue_get_events(&qq, qevs, 32);
		if (n == -1) {
			warn("quark_queue_get_events");
			break;
		}
		/* Scan each event */
		for (i = 0, qev = qevs; i < n; i++, qev++)
			quark_event_dump(qev, stdout);
		if (n == 0)
			quark_queue_block(&qq);
	}

	quark_queue_close(&qq);

	return (1);
}
.Ed
.Sh FURTHER READING
.Xr quark_queue_get_events 3
is the meat of the library and contains further useful documentation.
.Pp
.Xr quark-mon 8
is the easiest way to get started with
.Nm .
.Pp
.Xr quark_queue_open 3
describes initialization options that can be useful.
.Sh SEE ALSO
.Xr quark_event_dump 3 ,
.Xr quark_event_lookup 3 ,
.Xr quark_queue_block 3 ,
.Xr quark_queue_close 3 ,
.Xr quark_queue_get_epollfd 3 ,
.Xr quark_queue_get_events 3 ,
.Xr quark_queue_get_stats 3 ,
.Xr quark_queue_open 3 ,
.Xr quark-btf 8 ,
.Xr quark-mon 8
.Sh HISTORY
.Nm quark
started in April 2024.
